React

iniciar o projeto com o react-create-app
    react-create-app inicia o projeto com sintaxe do Es7

para configutar o webpack e outros scripts de inicialização:
    npm run eject
    OBS: é necessário que toda alteração no projeto esteja commitada.
    caso contrário o npm run eject dará erro.
    

Configurando para carregar módulos css (webpack.dev e .prod):
    ...
    module: {
        strictExportPresence: true,
        rules: [

            ...

            {
            test: /\.css$/,
                use: [
                    require.resolve('style-loader'),
                    {
                        loader: require.resolve('css-loader'),
                        options: {
                            importLoaders: 1,
                            modules: true,
                            localIdentName:'[name]__[local]__[hash:base64:5]'
                        },
                    },
                ]
            },
            ...
        ]
    },
    ...

    arquivo css(exemplo = App.css):
        .App {
            text-align: center;
        }


    No componente, importa-lo:
        import styles from './App.css';
    
    Uso:
        <div className={styles.App}>
            ...
        </div>

Debugando:
    Error Boundaries: https://reactjs.org/docs/error-boundaries.html

    Criar uma pasta para o componente ErrorBoundary como o noem que você desejar

    import React, { Component} from 'react';

    export  default class ErorrBoundary extends Component {
        state = {
            hasError: false,
            errorMessage: ''
        }

        componentDidCatch = (error, info) =>{
            this.setState({
                hasError: true,
                errorMessage: error
            });
        }

        render(){
            if(this.state.hasError){
                return <h1>{this.state.errorMessage}</h1>
            }
            else{
                return this.props.children;
            }
            
        }
    }

    no aplicativo, englobar o componente que você deseja capturar o erro com o componente
    ErrorBoundary:
    persons = (
        <div>
            {
                this.state.persons.map((person, index) =>{
                    return (
                        <ErrorBoundary key = {person.id}>	
                            <Person 
                                /*{key = {person.id}}*/
                                click = {()=>this.deletePersonHandler(index)}
                                name = {person.name}
                                age = {person.age}
                                changed = {(event) => this.nameChangeHandler(event, person.id)}
                            />
                        </ErrorBoundary>
                    );
                })
            }
        </div>
    );

    Como person é um compoenente de lista, sua key é passada para o errorBoundary, já que person
    é o componente a ser capturado.

Statefull e Stateless components:
    Statefull(containers):
        Normalmente classes com métodos
        Acesso a leitura e mudança de estados, propriedades
        Lifecyle hooks (extensão da classe React)

    Stateless:
        Somente função que recebem props
        Acessa apenas leitura de propriedades,
        Sem Lifecyle hoooks( é apenas uma função)
    

    Statefull lifecycle methods
        methods                                 executed at - order      

        cosntructor()                           creation - 1
        compoenentWillMount()(raramente usado)  creation - 2
        compoenentWillReceiveProps()
        compoenentWillUpdate()
        compoenentDidUpdate()
        compoenentDidCatch()
        compoenentDidMount()                    creation - 4
        compoenentWillUnmount()
        render()                                creation - 3

    Upadte Lifecycle by Props change:
        compoenentWillReceiveProps
            -> Sync State to Props
                    |
                    v

        shouldComponentUpdate(nextProps, nextState)
            -> pode ser cancelado: return true or false
                    |
                    v

        compoenentWillUpdate(nextProps, nextState)
          -> Sync State to Props
                    |
                    v

        render()
                    |
                    v 

        unpdate child component props
                    |
                    v 

        compoenentDidUpdate()
            -> efetuar os side effects(ajax calls e etc...)
    
    Quando Transformar um Stateless componentem um Statefull?
    só se ele receber props e você quer valida-las, como por exemplo, só atualiza
    se uma prop específica for de certo valor ou salvar performance caso um componente
    receba muitas props mas de fato não há mudança.


    
    Upadte Lifecycle by State change:
        shouldComponentUpdate(nextProps, nextState)
            -> pode ser cancelado: return true or false
                    |
                    v

        compoenentWillUpdate(nextProps, nextState)
          -> Sync State to Props
                    |
                    v

        render()
                    |
                    v 

        unpdate child component props
                    |
                    v 

        compoenentDidUpdate()
            -> efetuar os side effects(ajax calls e etc...)

    React PureComponents:
        import React, { PureComponent } from 'react';

        ...
        class App extends PureComponent {
            ...

        Implementa automáticamente uma validação de se realmente o state mudou
        para que o a função render seja cahmada.

        Substitui a função: shouldComponentUpdate(nextProps, nextState) se
        valida apenas o que foi alterado para otimização.
         