react-router vs react-router-dom
    Apenas react-router-dom precisa ser instalado.
    react-router era instalado anteriormente, agora já vem com react-router-dom,
    porém para se procurar na internet, procure o pacote como react-router

Renderizando rotas:
    ...
    import {BrowserRouter} from 'react-router-dom';
    ...

    class App extends Component {
        render() {
            return (
                <BrowserRouter>
                    <div className="App">
                    <Blog />
                    </div>
                </BrowserRouter>  
            );
        }
    }
    ...

    Então você pode criar as rotas nos arquivos internos que você desejar:
    neste caso é necessário importar Route do react-router-dom e configura-lo

    ...
    import {Route} from 'react-router-dom';
    ...

    class Blog extends Component {
      ...

        render () {
            return (
                <div className="Blog">
                    ...
                    <Route path="/" exact render={()=> <h1>Home</h1>} />
                    <Route path="/" exact component={Posts} />
                </div>
            );
        }
    }

    export default Blog;

    no exemplo acima:
    path:  é o caminho que é navegado no browser
    exact: deve ser exatamente este caminho
    render: é a função que deve ser executada quando o caminho for requisitado
    component: um Component é renderizado quando o caminho for requisitado (No caso o componente "Posts")

Navegando entre as rotas (funcionando de fato): 

   import {Link} from 'react-router-dom';
    ...
    <nav>
        <ul>
            <li>
                <Link to="/">Home</Link>
            </li>
            <li>
                <Link to={{
                    pathname: '/novo-post',
                    hash: '#submit',
                    search:'?quick-submit=true'
                }}>Novo Post</Link>
            </li>
        </ul>
    </nav>
    ...

    propriedades de "to" podem ser:
        pathname: a rota em si, no caso /novo-post 
        hash: uma ancora
        search: parametro passados para url

        todas as paths são absolutas, para torna-las relativas por exemplo 
        você está na página /posts e quer navegar para /posts/edit:

        <Link to={{
                pathname: this.props.match.url + '/edit'
            }}>Editar este post</Link>

            ou

        <Link to={{this.props.match.url + '/edit' }}>Editar este post</Link>

        
        desta forma a path será relativa à página post

    
    as propriedades da rota não estão disponíveis nos componentes filhos,
    apenas nos componentes setados em "<Route component={compoenente}/>".
    Porém usando uma HOC (High order function), chamada "withRouter" nativa do react-router-dom,
    isso é possível:

        import {withRouter} from 'react-router-dom';
        ...

        const post = (props) => {
            return (
                ... some jsx
            );
        }

        export default withRouter(post);

Estilizando links
    é necessário importar ao invés de "NavLink" ao invés de "Link":
    import {NavLink} from 'react-router-dom';
    ...
    <nav>
        <ul>
            <li>
                <NavLink to="/">Home</NavLink>
            </li>
            <li>
                <NavLink to={{
                    pathname: '/novo-post',
                    hash: '#submit',
                    search:'?quick-submit=true'
                }}>Novo Post</NavLink>
            </li>
        </ul>
    </nav>
    ...

    NavLink passa classes e outros argumentos para a rota,
    permitindo assim que você rastreie a rota para a qual você navegou

Switch, para pegar a primeira ocorrencia:
    ao navegar para /posts por exemplo
    caso hajam as seguintes rotas no compoenente:

        <Route path="/posts" component={Posts} />
        <Route path="/" component={Home} />
        

    ambas as rotas serão executadas pois a URL navegadas possui as duas expressõoes:
    "/" e "/posts".

    para que isso não ocorra, suar o compoenente Switch, que pega a primeira
    ocorrencia apenas:
        <Switch>
            <Route path="/posts" component={Posts} />
            <Route path="/" component={Home} />
        </Switch>

Extraindo parametros passados por uma rota:
    exemplo para carregar uma página de um post com com id 2:
        /post/2
        usa a propriedade matc.params, que é passada para props
       ...

        class FullPost extends Component {
            state = {
                loadedPost: null
            }

            componentDidMount(){
                if(this.props.match.params.id){ 
                    axios.get(`/posts/${this.props.match.params.id}`)
                    .then(response =>{
                        this.setState({loadedPost: response.data});
                    });
                }
            }

           ...
        }

        export default FullPost;

        para pegar uma serach query ou uma hash passada:
            hash: this.props.location.hash(statefull) ou  props.location.hash(stateless),
            search: this.props.location.search(statefull) ou props.location.search(stateless)

            parametro search retorna um array com chave e valor. Exemplo = ['busca', '5']
    

Navegando Programaticamente:
    quando você precisar executar alguma coisa antes de a rota ser buscada
    em alguma função de click:

    import React, {Component} from 'react';
        ...
        //import {Link} from 'react-router-dom';
        ...

        class Posts extends Component{
            ...

            getFullPost(id){
                //this.setState({selectedId:id});
                
                //this.props.history.push({pathname:`/${id}`});
                //ou
                this.props.history.push(`/${id}`);
            }
            
            render(){
                ...                
                posts = this.state.posts.map(post => {
                    return (
                        // <Link to={`/${post.id}`} key={post.id}>
                            <Post 
                                key={post.id}
                                title={post.title}
                                author={post.author}
                                click={()=>this.getFullPost.bind(this)(post.id)}
                            />
                        // </Link>    
                    )
                });

                return(
                    <section className="Posts">
                        {posts}
                    </section>
                );
            }
        };

        export default Posts;
    
    Redirect
        Redireciona para outra rota como o próprio nome diz:
        
        import {Route, Switch, Redirect} from 'react-router-dom';

        ....
            <Switch>
                <Route path="/posts" component={Posts} />
                <Route path="/" component={Home} />
                ...
                <Redirect from="/"  to="/posts" />
            </Switch>
        ...

        você pode usar o compoenente <Redirect /> para condicionalmente redirecionar caso
        um estado tenha mudado:

        ...
        class NewPost extends Component {
            state = {
                submited: false
            }

            render () {
                if(this.state.submited){
                    
                }
                return ()
            }
        }
        ...

        redirecionando com history.push ou history.replace

            após alguma ação qualquer você pode redirecionar 

            vamo supor que você esteja na página Home,

            this.props.history.push('/posts')

            que além de redirecionar para a página /posts, torna a página principal no histórico.
            Caso você aperte o botão voltar irá voltar para a página Home.

            this.props.history.replace('/posts')

            que apenas redireciona para a página /posts, subistituindo o histórico da página atual.
            Caso você aperte o botão voltar voltará para a página anterior a Home, neste caso.
    
    Guards
        Para navegar para rotas condicionalmente:

        {
            if(this.state.auth){
                <Route path="/novo-post" component={NewPost} />
            }
            else{
                null
            }
        }
    
    Capturando rotas não conhecidas ou 404:
        
        <Route render={() => <h1>Não encontrado!</h1>} />
        {/* <Redirect from="/"  to="/posts" /> */}

        porém não funciona em conjunto com path= "/", precisando retirar
        ou um ou outro.

        
    Lazy load : carregando componentes sob demanda:
        Necessário criar um componente de alta ordem:
            
            import React, {Component}  from 'react';

            const  asyncComponent = (importComponent) =>{
                return class extends Component{
                    state = {
                        component: null
                    }

                    componentDidMount(){
                        importComponent()
                            .then(cmpt =>{
                                this.setState({component:cmpt.default});
                            })
                    }

                    render(){
                        const COMPONENT = this.state.component;

                        return COMPONENT ? <COMPONENT {...this.props} /> : null;
                    }
                }
            }

            export default asyncComponent;

        No compoenente o qual fará a chamada assincrona:

            import asyncComponent from '../../hoc/ayncComponent';
            ...

            const AsyncNewPost = asyncComponent(() => {
                return import('../NewPost/NewPost');
            });


            ...

            class Blog extends Component {
                ...
                render () {
                    return (
                        <div className="Blog">
                        ...
                            <Switch>
                                <Route path="/novo-post" component={AsyncNewPost} />
                                ...
                            </Switch>
                            
                        </div>
                    );
                }
            }

    React app cmo sub-domínio:

        Setar a BrowserRouter com basename "/sub-domínio"

        import {BrowserRouter} from 'react-router-dom';

        class App extends Component {
            render() {
                return (
                <BrowserRouter basename="/sub-domínio">
                    <div className="App">
                    <Blog />
                    </div>
                </BrowserRouter>  
                );
            }
        }

            export default App;

Links:
    React Router Docs: https://reacttraining.com/react-router/web/guides/philosophy