React

iniciar o projeto com o react-create-app
    react-create-app inicia o projeto com sintaxe do Es7

para configutar o webpack e outros scripts de inicialização:
    npm run eject
    OBS: é necessário que toda alteração no projeto esteja commitada.
    caso contrário o npm run eject dará erro.
    

Configurando para carregar módulos css (webpack.dev e .prod):
    ...
    module: {
        strictExportPresence: true,
        rules: [

            ...

            {
            test: /\.css$/,
                use: [
                    require.resolve('style-loader'),
                    {
                        loader: require.resolve('css-loader'),
                        options: {
                            importLoaders: 1,
                            modules: true,
                            localIdentName:'[name]__[local]__[hash:base64:5]'
                        },
                    },
                ]
            },
            ...
        ]
    },
    ...

    arquivo css(exemplo = App.css):
        .App {
            text-align: center;
        }


    No componente, importa-lo:
        import styles from './App.css';
    
    Uso:
        <div className={styles.App}>
            ...
        </div>

    Escopo de módulos css:

        exemplo:
        no arquivo Logo.css (que é importado junto ao componente Logo):
            .Logo{
                padding: 8px;
                height: 80%;
                box-sizing: border-box;
                border-radius: 5px;
            }

        porém a altura deve ser modificada quando o logo estiver
        dentro do Sidedrawe.
        
        no arquivo sidedrawer.css:
            .Sidedrawer .Logo{
                height: 11%;
            }

        então é necessário importar o componente logo no componente sidedrawer

        import React from 'react';
        import Logo from '..Logo path';
        import styles from './Sidedrawer.css';

        const sidedrawer = (props) =>{
            return (
                <div className={styles.Sidedrawer}>
                    <div className={styles.Logo}>
                        <Logo />
                    </div>
                </div>
            );
        }

Debugando:
    Error Boundaries: https://reactjs.org/docs/error-boundaries.html

    Criar uma pasta para o componente ErrorBoundary como o noem que você desejar

    import React, { Component} from 'react';

    export  default class ErorrBoundary extends Component {
        state = {
            hasError: false,
            errorMessage: ''
        }

        componentDidCatch = (error, info) =>{
            this.setState({
                hasError: true,
                errorMessage: error
            });
        }

        render(){
            if(this.state.hasError){
                return <h1>{this.state.errorMessage}</h1>
            }
            else{
                return this.props.children;
            }
            
        }
    }

    no aplicativo, englobar o componente que você deseja capturar o erro com o componente
    ErrorBoundary:
    persons = (
        <div>
            {
                this.state.persons.map((person, index) =>{
                    return (
                        <ErrorBoundary key = {person.id}>	
                            <Person 
                                /*{key = {person.id}}*/
                                click = {()=>this.deletePersonHandler(index)}
                                name = {person.name}
                                age = {person.age}
                                changed = {(event) => this.nameChangeHandler(event, person.id)}
                            />
                        </ErrorBoundary>
                    );
                })
            }
        </div>
    );

    Como person é um compoenente de lista, sua key é passada para o errorBoundary, já que person
    é o componente a ser capturado.

    NOTA: props.children é um component, ou connteúdo filho que esta sendo passado:
    <Container>
        <Filho></Filho>
    </Container>
    neste caso Filho é o props.children de Container

Statefull e Stateless components:
    Statefull:
        Normalmente classes com métodos
        Acesso a leitura e mudança de estados, propriedades
        Lifecyle hooks (extensão da classe React)

    Stateless:
        Somente função que recebem props
        Acessa apenas leitura de propriedades,
        Sem Lifecyle hoooks( é apenas uma função)
    

    Statefull lifecycle methods
        methods                                                     executed at - order      

        cosntructor()                                               creation - 1
        compoenentWillMount()(Não recomendado react 16.3+)          creation - 2
        compoenentWillReceiveProps()(Não recomendado react 16.3+)
        compoenentWillUpdate()(Não recomendado react 16.3+)
        compoenentDidUpdate()
        compoenentDidCatch()
        compoenentDidMount()                                        creation - 4
        compoenentWillUnmount()
        render()                                                    creation - 3
        getDerivedStateFromProps(nextProps, prevState)(Novo 16.3+)


    Upadte Lifecycle by Props change:
        compoenentWillReceiveProps
            -> Sync State to Props
                    |
                    v

        shouldComponentUpdate(nextProps, nextState)
            -> pode ser cancelado: return true or false
                    |
                    v

        compoenentWillUpdate(nextProps, nextState)
          -> Sync State to Props
                    |
                    v

        render()
                    |
                    v 

        unpdate child component props
                    |
                    v 

        compoenentDidUpdate()
            -> efetuar os side effects(ajax calls e etc...)
    
    Quando Transformar um Stateless componentem um Statefull?
    só se ele receber props e você quer valida-las, como por exemplo, só atualiza
    se uma prop específica for de certo valor ou salvar performance caso um componente
    receba muitas props mas de fato não há mudança ou quando ele está alterando áreas não
    visíveis, disperdiçãndo performance, neste caso, deve-se atualiza-lo para statefull e
    validar se deve se atualizado quando ocorrer uma mudação de estado (shouldComponentUpdate).


    
    Upadte Lifecycle by State change:
        shouldComponentUpdate(nextProps, nextState)
            -> pode ser cancelado: return true or false
                    |
                    v

        compoenentWillUpdate(nextProps, nextState)
          -> Sync State to Props
                    |
                    v

        render()
                    |
                    v 

        unpdate child component props
                    |
                    v 

        compoenentDidUpdate()
            -> efetuar os side effects(ajax calls e etc...)

    React PureComponents:
        import React, { PureComponent } from 'react';

        ...
        class App extends PureComponent {
            ...

        Implementa automáticamente uma validação de se realmente o state mudou
        para que o a função render seja cahmada.

        Substitui a função: shouldComponentUpdate(nextProps, nextState) se
        valida apenas o que foi alterado para otimização.

     Performance:
            PureComponents são usados em Containers enquanto que shouldComponentUpdate()
            deve ser usado em outros componentes que não gerenciam estado porém atualizam
            props desnecessária mente, como por exemplo atualizar um modal sem mostra-lo.
    
    React render() function retornando elementos multiplos:
        O react aceita apenas um elemento unico de retorno na função render():
        
        return (
            <div>
                <p onClick={this.props.click}>I'm {this.props.name} and I am {this.props.age} years old!</p>
                <p>{this.props.children}</p>
                <input type="text" onChange={this.props.changed} value={this.props.name}/>
            </div>
        );

        elementos multiplos precisam estar englobados em um unico elemento, como é o caso acima.

        existe porém, 2 alternativas a partir do React 16:

        1 - retornando um Array:
            return [
                <p onClick={this.props.click}>I'm {this.props.name} and I am {this.props.age} years old!</p>,
                <p>{this.props.children}</p>,
                <input type="text" onChange={this.props.changed} value={this.props.name}/>
            ];
        
        2 Criando um High order Component(HOC) ou fragments: 
            Serve para quando voce não quer adicionar uma nova div ao HTML 
            porém precisa emglobar multiplos elementos.

            Aux.js:

                const aux = (props) => props.children;
                export default aux;

            import Aux from '..path to Aux component';
            ...
            return(
                <Aux>
                    <p onClick={this.props.click}>I'm {this.props.name} and I am {this.props.age} years old!</p>,
                    <p>{this.props.children}</p>,
                    <input type="text" onChange={this.props.changed} value={this.props.name}/>
                </Aux>
            );

            NOTA: no React 16.2 já existe um elemento Hoc nativo: transformando o código anterior em:
            ...
            return(
                <Fragment>
                    <p onClick={this.props.click}>I'm {this.props.name} and I am {this.props.age} years old!</p>,
                    <p>{this.props.children}</p>,
                    <input type="text" onChange={this.props.changed} value={this.props.name}/>
                </Fragment>
            ); 

            Mantendo a mesma função, sem a necessidade de criar um arquivo.
        
    High Order Components(HOC):
        High order components pra retornar componentes
        com classes CSS e stateFull compoenets:

        criar um arquivo que retorna uma função a ser englobada no componenete:
        exemplo: withClass.js

        Componente Stateless:
            import React from 'react';

            const withClass = (WrappedComponent, className) =>{
                return (props) => ( 
                    <div className = {className}>
                        <WrappedComponent {...props} />
                    </div>
                )
            }
            export default withClass;

        Componente Statefull:
            import React, { Component } from 'react';

            const withClass = (WrappedComponent, className) =>{
                return class extends Component{ //class on Demand
                    render(){
                        return( 
                            <div className = {className}>
                                <WrappedComponent {...this.props} />
                            </div>
                        );
                    }
                }
            }
            export default withClass;

            exemplo de uso:
                
            import React, { PureComponent, Fragment } from 'react';
            ...
            import withClass from '../hoc/withClass';

            class App extends PureComponent {
                ...

                render() {
                    return (
                        <Fragment>
                            <button onClick={()=>{this.setState({showPersons:true})}}>Show Persons</button>
                            <Cockpit
                                appTitle = {this.props.title}
                                showPersons = {this.state.showPersons}
                                qtdPersons = {this.state.persons.length}
                                clicked = {this.togglePersonHandler.bind(this)}/>
                            {listPersons}
                        </Fragment>
                    );
                }
            }

            export default withClass(App, styles.App);
    
    O jeito certo de usar o metodo setState(exemplo):
        É usar p prevState caso deseje modificar ou atualizar o estado. Previnindo assim 
        que o haja problemas caso o estado seja mudado ao mesmo tempo em outra parte da
        aplicação.

        ...

        const doesShow = this.state.showPersons;

        this.setState((prevState, props)=>{
            return {
                showPersons: !doesShow,
                toggleClicked: prevState.toggleClicked + 1
            }
        });
    
    Validação de tipo das propriedades dos componentes:
        npm install --save prop-types

        no componente Person.js (precisa ser um statefull component, ou seja, um componente criado com class):

            import PropTypes from 'prop-types';

            class Person extends Component {
               ...
            }

            Person.propTypes = {
                click: PropTypes.func, //click precisa ser function
                name: PropTypes.string, //name precisa ser string
                age: PropTypes.number, //number precisa ser numérico
                changed: PropTypes.func //changed precisa ser function
            };

        link dos tipos disponíveis para validação:
        https://reactjs.org/docs/typechecking-with-proptypes.html
    

    Refs
        é uma maneira de capturar uma função executada no componente filho,
        para ser tratado pelo componente pai,
        quando usar:
            gerir focus, seleção de texto, ou media playback.
            acionando animações.
            Integrar com bibliotecas DOM de terceiros.

        no component filho, definir a referência:
            exemplo: Person.js

            React.createRef() => React 16.3 +

            ES7 sintaxe:
                class Person extends Component {

                    inputElem = React.createRef(); 
                    ...

            ES6 sintaxe:
                class Person extends Component {

                    constructor(props){
                        super(props);
                        this.inputElem = React.createRef();
                    }
                    
                    ...


                    funcaoDoFilho(){
                        this.inputElem.current.focus();
                    }
            
                    render(){
                        return (
                            <Fragment>
                            ...
                                <input 
                                    ref={this.inputElem}
                                    type="text" />
                            </Fragment>
                        );
                    }

        no component pai
             class Persons extends Component {

                lastPersonRef = React.createRef()
                    ...
                
                componentDidMount(){
                    this.lastPersonRef.current.funcaoDoFilho();
                }
    
                render(){
                    return this.props.persons.map((person, index) =>{
                        
                        return <Person 
                            key = {person.id}
                            position = {index}
                            ...
                            ref={this.lastPersonRef} />
                    });
                }  

        Retornando referência para componente pai em HOC:
            alterar o HOC withClass desta maneira:
                import React, { Component, forwardRef } from 'react';

                const withClass = (WrappedComponent, className) =>{
                    const WithClass = class extends Component{ //class on Demand
                        render(){
                            return( 
                                <div className = {className}>
                                    <WrappedComponent ref={this.props.childRefs} {...this.props} />
                                </div>
                            );
                        }
                    }
                    
                    return forwardRef((props, ref)=>{
                        return <WithClass {...props} childRefs={ref} />
                    });
                }
                export default withClass;


    Contex APi (React 16.3+):
        Usado para transmissão de dados que são considerados globais
        exemplo:
            import React from 'react';
            export const AuthContext = React.createContext(false);

            class App extends PureComponent {
                ...

                render() {
                    
                    return (
                        <Fragment>
                            ...
                            
                            <AuthContext.Provider value={this.state.authenticated}>
                                {listPersons}
                            </AuthContext.Provider>
                        </Fragment>
                    );
                }
            }

            No componente filho, não importanto o nível:

            import { AuthContext } from '../../containers/App';

            class Person extends Component {

                ...
                render(){
                    return (
                        <Fragment>
                            <AuthContext.Consumer>
                                {auth => auth ? <p>I'm authenticated</p> : null}
                            </AuthContext.Consumer>  
                        ...
                    )
                }
    
    Novos Metodos do ciclo de vida do React:
        static getDerivedStateFromProps(nextProps, prevState):
            atualiza o estado de acordo com as propriedades(props)
            retornando o novo estado.
            É executado antes do metodo render e componentDidMount;
        
        getSnapshotBeforeUpdate()
            usado antes de atualizar o DOM, para guardar alguma informção
            do DOM antigo que pode ser reutilizada
            É executado antes do metodo componentDidUpdate;
    
    Recursos e itens Uteis:
        State & Lifecycle: https://reactjs.org/docs/state-and-lifecycle.html
        PropTypes: https://reactjs.org/docs/typechecking-with-proptypes.html
        Higher Order Components: https://reactjs.org/docs/higher-order-components.html
        Refs: https://reactjs.org/docs/refs-and-the-dom.html
        
    Validação:
        usar redux-forms: (não tem aula sobre este assunto neste curso)